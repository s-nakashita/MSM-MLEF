C-----------------------------------------------------------------------
      SUBROUTINE POLATES0(IPOPT,KGDSI,KGDSO,MI,MO,KM,IBI,LI,GI,
     &                    NO,RLAT,RLON,IBO,LO,GO,IRET)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:  POLATES0   INTERPOLATE SCALAR FIELDS (BILINEAR)
C   PRGMMR: IREDELL       ORG: W/NMC23       DATE: 96-04-10
C
C ABSTRACT: THIS SUBPROGRAM PERFORMS BILINEAR INTERPOLATION
C           FROM ANY GRID TO ANY GRID FOR SCALAR FIELDS.
C           OPTIONS ALLOW VARYING THE MINIMUM PERCENTAGE FOR MASK,
C           I.E. PERCENT VALID INPUT DATA REQUIRED TO MAKE OUTPUT DATA,
C           (IPOPT(1)) WHICH DEFAULTS TO 50 (IF IPOPT(1)=-1).
C           ONLY HORIZONTAL INTERPOLATION IS PERFORMED.
C           IF NO INPUT DATA IS FOUND NEAR THE OUTPUT POINT, A SPIRAL
C           SEARCH MAY BE INVOKED BY SETTING IPOPT(2)> 0.
C           NO SEARCHING IS DONE IF OUTPUT POINT IS OUTSIDE THE INPUT GRID.
C           THE GRIDS ARE DEFINED BY THEIR GRID DESCRIPTION SECTIONS
C           (PASSED IN INTEGER FORM AS DECODED BY SUBPROGRAM W3FI63).
C           THE CURRENT CODE RECOGNIZES THE FOLLOWING PROJECTIONS:
C             (KGDS(1)=000) EQUIDISTANT CYLINDRICAL
C             (KGDS(1)=001) MERCATOR CYLINDRICAL
C             (KGDS(1)=003) LAMBERT CONFORMAL CONICAL
C             (KGDS(1)=004) GAUSSIAN CYLINDRICAL (SPECTRAL NATIVE)
C             (KGDS(1)=005) POLAR STEREOGRAPHIC AZIMUTHAL
C             (KGDS(1)=202) ROTATED EQUIDISTANT CYLINDRICAL (ETA NATIVE)
C           WHERE KGDS COULD BE EITHER INPUT KGDSI OR OUTPUT KGDSO.
C           AS AN ADDED BONUS THE NUMBER OF OUTPUT GRID POINTS
C           AND THEIR LATITUDES AND LONGITUDES ARE ALSO RETURNED.
C           ON THE OTHER HAND, THE OUTPUT CAN BE A SET OF STATION POINTS
C           IF KGDSO(1)<0, IN WHICH CASE THE NUMBER OF POINTS
C           AND THEIR LATITUDES AND LONGITUDES MUST BE INPUT.
C           INPUT BITMAPS WILL BE INTERPOLATED TO OUTPUT BITMAPS.
C           OUTPUT BITMAPS WILL ALSO BE CREATED WHEN THE OUTPUT GRID
C           EXTENDS OUTSIDE OF THE DOMAIN OF THE INPUT GRID.
C           THE OUTPUT FIELD IS SET TO 0 WHERE THE OUTPUT BITMAP IS OFF.
C        
C PROGRAM HISTORY LOG:
C   96-04-10  IREDELL
C 1999-04-08  IREDELL  SPLIT IJKGDS INTO TWO PIECES
C 2001-06-18  IREDELL  INCLUDE MINIMUM MASK PERCENTAGE OPTION
C 2007-05-22  IREDELL  EXTRAPOLATE UP TO HALF A GRID CELL
C 2008-06-04  GAYNO    ADDED SPIRAL SEARCH OPTION
C
C USAGE:    CALL POLATES0(IPOPT,KGDSI,KGDSO,MI,MO,KM,IBI,LI,GI,
C    &                    NO,RLAT,RLON,IBO,LO,GO,IRET)
C
C   INPUT ARGUMENT LIST:
C     IPOPT    - INTEGER (20) INTERPOLATION OPTIONS
C                IPOPT(1) IS MINIMUM PERCENTAGE FOR MASK
C                (DEFAULTS TO 50 IF IPOPT(1)=-1)
C                IPOPT(2) IS WIDTH OF SQUARE TO EXAMINE IN SPIRAL SEARCH
C                (DEFAULTS TO NO SEARCH IF IPOPT(2)=-1)
C     KGDSI    - INTEGER (200) INPUT GDS PARAMETERS AS DECODED BY W3FI63
C     KGDSO    - INTEGER (200) OUTPUT GDS PARAMETERS
C                (KGDSO(1)<0 IMPLIES RANDOM STATION POINTS)
C     MI       - INTEGER SKIP NUMBER BETWEEN INPUT GRID FIELDS IF KM>1
C                OR DIMENSION OF INPUT GRID FIELDS IF KM=1
C     MO       - INTEGER SKIP NUMBER BETWEEN OUTPUT GRID FIELDS IF KM>1
C                OR DIMENSION OF OUTPUT GRID FIELDS IF KM=1
C     KM       - INTEGER NUMBER OF FIELDS TO INTERPOLATE
C     IBI      - INTEGER (KM) INPUT BITMAP FLAGS
C     LI       - LOGICAL*1 (MI,KM) INPUT BITMAPS (IF SOME IBI(K)=1)
C     GI       - REAL (MI,KM) INPUT FIELDS TO INTERPOLATE
C     NO       - INTEGER NUMBER OF OUTPUT POINTS (ONLY IF KGDSO(1)<0)
C     RLAT     - REAL (NO) OUTPUT LATITUDES IN DEGREES (IF KGDSO(1)<0)
C     RLON     - REAL (NO) OUTPUT LONGITUDES IN DEGREES (IF KGDSO(1)<0)
C
C   OUTPUT ARGUMENT LIST:
C     NO       - INTEGER NUMBER OF OUTPUT POINTS (ONLY IF KGDSO(1)>=0)
C     RLAT     - REAL (MO) OUTPUT LATITUDES IN DEGREES (IF KGDSO(1)>=0)
C     RLON     - REAL (MO) OUTPUT LONGITUDES IN DEGREES (IF KGDSO(1)>=0)
C     IBO      - INTEGER (KM) OUTPUT BITMAP FLAGS
C     LO       - LOGICAL*1 (MO,KM) OUTPUT BITMAPS (ALWAYS OUTPUT)
C     GO       - REAL (MO,KM) OUTPUT FIELDS INTERPOLATED
C     IRET     - INTEGER RETURN CODE
C                0    SUCCESSFUL INTERPOLATION
C                2    UNRECOGNIZED INPUT GRID OR NO GRID OVERLAP
C                3    UNRECOGNIZED OUTPUT GRID
C
C SUBPROGRAMS CALLED:
C   GDSWIZ       GRID DESCRIPTION SECTION WIZARD
C   IJKGDS0      SET UP PARAMETERS FOR IJKGDS1
C   (IJKGDS1)    RETURN FIELD POSITION FOR A GIVEN GRID POINT
C   POLFIXS      MAKE MULTIPLE POLE SCALAR VALUES CONSISTENT
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C
C$$$
CFPP$ EXPAND(IJKGDS1)
      INTEGER IPOPT(20)
      INTEGER KGDSI(200),KGDSO(200)
      INTEGER IBI(KM),IBO(KM)
      LOGICAL*1 LI(MI,KM),LO(MO,KM)
      REAL GI(MI,KM),GO(MO,KM)
      REAL RLAT(MO),RLON(MO)
      REAL XPTS(MO),YPTS(MO)
      REAL WO(MO)
      INTEGER N11(MO),N21(MO),N12(MO),N22(MO)
      REAL W11(MO),W21(MO),W12(MO),W22(MO)
      INTEGER IJKGDSA(20)
      PARAMETER(FILL=-9999.)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  COMPUTE NUMBER OF OUTPUT POINTS AND THEIR LATITUDES AND LONGITUDES.
      IRET=0
      IF(KGDSO(1).GE.0) THEN
        CALL GDSWIZ(KGDSO, 0,MO,FILL,XPTS,YPTS,RLON,RLAT,NO,0,DUM,DUM)
        IF(NO.EQ.0) IRET=3
      ENDIF
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  SET PARAMETERS
      MP=IPOPT(1)
      IF(MP.EQ.-1.OR.MP.EQ.0) MP=50
      IF(MP.LT.0.OR.MP.GT.100) IRET=32
      PMP=MP*0.01
      MSPIRAL=MAX(IPOPT(2),0)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  LOCATE INPUT POINTS AND COMPUTE THEIR WEIGHTS
      CALL GDSWIZ(KGDSI,-1,NO,FILL,XPTS,YPTS,RLON,RLAT,NV,0,DUM,DUM)
      IF(IRET.EQ.0.AND.NV.EQ.0) IRET=2
      CALL IJKGDS0(KGDSI,IJKGDSA)
      DO N=1,NO
        XI=XPTS(N)
        YI=YPTS(N)
        IF(XI.NE.FILL.AND.YI.NE.FILL) THEN
          I1=XI
          I2=I1+1
          J1=YI
          J2=J1+1
          XF=XI-I1
          YF=YI-J1
          N11(N)=IJKGDS1(I1,J1,IJKGDSA)
          N21(N)=IJKGDS1(I2,J1,IJKGDSA)
          N12(N)=IJKGDS1(I1,J2,IJKGDSA)
          N22(N)=IJKGDS1(I2,J2,IJKGDSA)
          IF(N11(N).GT.0) THEN
            W11(N)=(1-XF)*(1-YF)
          ELSE
            W11(N)=0.
          ENDIF
          IF(N21(N).GT.0) THEN
            W21(N)=XF*(1-YF)
          ELSE
            W21(N)=0.
          ENDIF
          IF(N12(N).GT.0) THEN
            W12(N)=(1-XF)*YF
          ELSE
            W12(N)=0.
          ENDIF
          IF(N22(N).GT.0) THEN
            W22(N)=XF*YF
          ELSE
            W22(N)=0.
          ENDIF
        ELSE
          N11(N)=0
          N21(N)=0
          N12(N)=0
          N22(N)=0
        ENDIF
      ENDDO
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  INTERPOLATE WITH OR WITHOUT BITMAPS
CMIC$ DO ALL AUTOSCOPE PRIVATE(WO)
      DO K=1,KM
        DO N=1,NO
          GO(N,K)=0.
          WO(N)=0.
          IF(N11(N).GT.0.AND.(IBI(K).EQ.0.OR.LI(N11(N),K))) THEN
            GO(N,K)=GO(N,K)+W11(N)*GI(N11(N),K)
            WO(N)=WO(N)+W11(N)
          ENDIF
          IF(N21(N).GT.0.AND.(IBI(K).EQ.0.OR.LI(N21(N),K))) THEN
            GO(N,K)=GO(N,K)+W21(N)*GI(N21(N),K)
            WO(N)=WO(N)+W21(N)
          ENDIF
          IF(N12(N).GT.0.AND.(IBI(K).EQ.0.OR.LI(N12(N),K))) THEN
            GO(N,K)=GO(N,K)+W12(N)*GI(N12(N),K)
            WO(N)=WO(N)+W12(N)
          ENDIF
          IF(N22(N).GT.0.AND.(IBI(K).EQ.0.OR.LI(N22(N),K))) THEN
            GO(N,K)=GO(N,K)+W22(N)*GI(N22(N),K)
            WO(N)=WO(N)+W22(N)
          ENDIF
        ENDDO
        IBO(K)=IBI(K)
        DO N=1,NO
          LO(N,K)=WO(N).GE.PMP
          IF(LO(N,K)) THEN
            GO(N,K)=GO(N,K)/WO(N)
          ELSEIF(MSPIRAL.GT.0.AND.XPTS(N).NE.FILL.AND.
     &                            YPTS(N).NE.FILL) THEN
            I1=NINT(XPTS(N))
            J1=NINT(YPTS(N))
            IXS=SIGN(1.,XPTS(N)-I1)
            JXS=SIGN(1.,YPTS(N)-J1)
            SPIRAL : DO MX=1,MSPIRAL**2
              KXS=SQRT(4*MX-2.5)
              KXT=MX-(KXS**2/4+1)
              SELECT CASE(MOD(KXS,4))
              CASE(1)
                IX=I1-IXS*(KXS/4-KXT)
                JX=J1-JXS*KXS/4
              CASE(2)
                IX=I1+IXS*(1+KXS/4)
                JX=J1-JXS*(KXS/4-KXT)
              CASE(3)
                IX=I1+IXS*(1+KXS/4-KXT)
                JX=J1+JXS*(1+KXS/4)
              CASE DEFAULT
                IX=I1-IXS*KXS/4
                JX=J1+JXS*(KXS/4-KXT)
              END SELECT
              NX=IJKGDS1(IX,JX,IJKGDSA)
              IF(NX.GT.0.)THEN
                IF(LI(NX,K).OR.IBI(K).EQ.0)THEN
                  GO(N,K)=GI(NX,K)
                  LO(N,K)=.TRUE.
                  EXIT SPIRAL
                ENDIF
              ENDIF
            ENDDO SPIRAL
            IF(.NOT.LO(N,K))THEN
              IBO(K)=1
              GO(N,K)=0.
            ENDIF
          ELSE
            IBO(K)=1
            GO(N,K)=0.
          ENDIF
        ENDDO
      ENDDO
      IF(KGDSO(1).EQ.0) CALL POLFIXS(NO,MO,KM,RLAT,RLON,IBO,LO,GO)
C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      END
